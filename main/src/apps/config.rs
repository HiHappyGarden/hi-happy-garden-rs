/***************************************************************************
 *
 * Hi Happy Garden
 * Copyright (C) 2023/2026 Antonio Salsi <passy.linux@zresa.it>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 ***************************************************************************/
#![allow(dead_code)]

use alloc::format;
use alloc::string::String;

use cjson_binding::{from_json, to_json};

use osal_rs::log_info;
use osal_rs::os::{RawMutex, RawMutexFn};
use osal_rs::utils::Bytes;
use osal_rs::utils::{Result, Error};

use osal_rs_serde::{Deserialize, Serialize};

use crate::drivers::filesystem::{open_flags, FileBytes, Filesystem};
use crate::drivers::wifi::Auth;
use crate::drivers::platform::{FS_CONFIG_DIR, FS_SEPARATOR_DIR};
use crate::traits::state::Initializable;

// Include default configuration values generated by build.rs from CMake
mod defaults {
    include!(concat!(env!("OUT_DIR"), "/defaults.rs"));
}

const APP_TAG: &str = "Config";

static mut MUTEX: Option<RawMutex> = None;

const fn mutex() -> &'static RawMutex {
    unsafe {
        match &*&raw const MUTEX {
            Some(mutex) => mutex,
            None => panic!("EVENT_HANDLER is not initialized"),
        }
    }
}

static mut CONFIG: Config = Config {
    version: 0,
    serial: Bytes::new(),
    timezone: 0,
    daylight_saving_time: false,
    users: [UserConfig {
        user: Bytes::new(),
        password: Bytes::new()
    }; 2],
    wifi: WifiConfig {
        ssid: Bytes::new(),
        password: Bytes::new(),
        hostname: Bytes::new(),
        auth: Auth::Wpa2,
        enabled: false
    },
    ntp: NtpConfig {
        server: Bytes::new(),
        port: 123,
        msg_len: 48,
        enabled: false
    }
};

#[derive(Serialize, Deserialize, Clone, Copy)]
pub struct WifiConfig {
    ssid: Bytes<32>,
    password: Bytes<64>,
    hostname: Bytes<32>,
    auth: Auth,
    enabled: bool,
}

impl Default for WifiConfig {
    fn default() -> Self {
        Self {
            ssid: Bytes::new(),
            password: Bytes::new(),
            hostname: Bytes::new(),
            auth: Auth::Wpa2,
            enabled: false,
        }
    }
}

impl WifiConfig {
    pub fn get_ssid(&self) -> &Bytes<32> {
        mutex().lock();
        let ssid = &self.ssid;
        mutex().unlock();
        ssid
    }

    pub fn get_password(&self) -> &Bytes<64> {
        mutex().lock();
        let password = &self.password;
        mutex().unlock();
        password
    }

    pub fn get_hostname(&self) -> &Bytes<32> {
        mutex().lock();
        let hostname = &self.hostname;
        mutex().unlock();
        hostname
    }

    pub fn is_enabled(&self) -> bool {
        mutex().lock();
        let enabled = self.enabled;
        mutex().unlock();
        enabled
    }

    pub fn get_auth(&self) -> Auth {
        mutex().lock();
        let auth = self.auth;
        mutex().unlock();
        auth
    }

    pub fn set_ssid(&mut self, ssid: Bytes<32>) {
        mutex().lock();
        self.ssid = ssid;
        mutex().unlock();
    }

    pub fn set_password(&mut self, password: Bytes<64>) {
        mutex().lock();
        self.password = password;
        mutex().unlock();
    }

    pub fn set_hostname(&mut self, hostname: Bytes<32>) {
        mutex().lock();
        self.hostname = hostname;
        mutex().unlock();
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        mutex().lock();
        self.enabled = enabled;
        mutex().unlock();
    }

    pub fn set_auth(&mut self, auth: Auth) {
        mutex().lock();
        self.auth = auth;
        mutex().unlock();
    }
}

#[derive(Serialize, Deserialize, Clone, Copy)]
pub struct NtpConfig {
    server: Bytes<64>,
    port: u16,
    msg_len: u16,
    enabled: bool,
}

impl Default for NtpConfig {
    fn default() -> Self {
        Self {
            server: Bytes::new(),
            port: 123,
            msg_len: 48,
            enabled: false,
        }
    }
}

impl NtpConfig {
    pub fn get_server(&self) -> &Bytes<64> {
        mutex().lock();
        let server = &self.server;
        mutex().unlock();
        server
    }

    pub fn get_port(&self) -> u16 {
        mutex().lock();
        let port = self.port;
        mutex().unlock();
        port
    }

    pub fn get_msg_len(&self) -> u16 {
        mutex().lock();
        let msg_len = self.msg_len;
        mutex().unlock();
        msg_len
    }

    pub fn set_server(&mut self, server: Bytes<64>) {
        mutex().lock();
        self.server = server;
        mutex().unlock();
    }

    pub fn set_port(&mut self, port: u16) {
        mutex().lock();
        self.port = port;
        mutex().unlock();
    }

    pub fn set_msg_len(&mut self, msg_len: u16) {
        mutex().lock();
        self.msg_len = msg_len;
        mutex().unlock();
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        mutex().lock();
        self.enabled = enabled;
        mutex().unlock();
    }

    pub fn is_enabled(&self) -> bool {
        mutex().lock();
        let enabled = self.enabled;
        mutex().unlock();
        enabled
    }
}

#[derive(Serialize, Deserialize, Clone, Copy)]
pub struct UserConfig {
    user: Bytes<32>,
    password: Bytes<64>
}

impl Default for UserConfig {
    fn default() -> Self {
        Self {
            user: Bytes::new(),
            password: Bytes::new()
        }
    }
}

impl UserConfig {
    pub fn get_user(&self) -> &Bytes<32> {
        mutex().lock();
        let user = &self.user;
        mutex().unlock();
        user
    }

    pub fn get_password(&self) -> &Bytes<64> {
        mutex().lock();
        let password = &self.password;
        mutex().unlock();
        password
    }

    pub fn set_user(&mut self, user: Bytes<32>) {
        mutex().lock();
        self.user = user;
        mutex().unlock();
    }

    pub fn set_password(&mut self, password: Bytes<64>) {
        mutex().lock();
        self.password = password;
        mutex().unlock();
    }
    
}


#[derive(Serialize, Deserialize, Clone, Copy)]
pub struct Config {
    version: u8,
    serial: Bytes<16>,
    timezone: u16,
    daylight_saving_time: bool,
    users: [UserConfig; 2],
    wifi: WifiConfig,
    ntp: NtpConfig,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            version: 0,
            serial: Bytes::new(),
            timezone: 0,
            daylight_saving_time: false,
            users: [Default::default(); 2],
            wifi: Default::default(),
            ntp: NtpConfig::default()
        }
    }
}


impl Initializable for Config {
    fn init(&mut self) -> Result<()> {
        log_info!(APP_TAG, "Init config");

        unsafe {
            MUTEX = Some(RawMutex::new()?);
        }

        let _ = Self::load()?;

        Ok(())
    }
}

impl Config {

    const FILE_NAME: &'static str = "config.json";

    /// Initialize Config with default values from CMake
    fn with_defaults() -> Self {
        let mut config = Self::default();
        
        // Apply CMake defaults to WiFi config
        config.wifi.ssid = Bytes::new_by_str(defaults::DEFAULT_WIFI_SSID);
        config.wifi.password = Bytes::new_by_str(defaults::DEFAULT_WIFI_PASSWORD);
        config.wifi.hostname = Bytes::new_by_str(defaults::DEFAULT_WIFI_HOSTNAME);
        config.wifi.enabled = defaults::DEFAULT_WIFI_ENABLED;
        
        // Apply CMake defaults to general config
        config.timezone = defaults::DEFAULT_TIMEZONE;
        config.daylight_saving_time = defaults::DEFAULT_DAYLIGHT_SAVING;
        
        config
    }

    pub const fn new() -> &'static mut Self {
        unsafe {
            &mut *&raw mut CONFIG
        }
    }

    pub fn load() -> Result<&'static mut Self> {
        let mut file_name = FileBytes::new_by_str(FS_CONFIG_DIR);
        file_name.append_str(FS_SEPARATOR_DIR);
        file_name.append_str(Config::FILE_NAME);

        let mut file = match Filesystem::open_with_as_sync_str(&file_name, open_flags::RDWR | open_flags::CREAT) {
            Ok(file) => file,
            Err(e @ Error::ReturnWithCode(-2) )  => {
                log_info!(APP_TAG, "Failed to open config file: {e}, try to create it");
                Filesystem::open_with_as_sync_str(&file_name, open_flags::WRONLY | open_flags::CREAT)?
            }
            Err(e) => return Err(e),
        };

        let wifi_json = file.read_with_as_sync_str(true)?;

        // If file is empty or doesn't exist, use defaults
        if wifi_json.is_empty() {
            log_info!(APP_TAG, "Config file not found or empty, using defaults");
            unsafe {
                CONFIG = Self::with_defaults();
            }

            Self::save()?;

            return Ok(unsafe { &mut *&raw mut CONFIG });
        }
        
        let wifi_json = match String::from_utf8(wifi_json) {
            Ok(json) => json,
            Err(e) => {
                return Err(Error::UnhandledOwned(format!("Failed to parse config JSON: {e}")));
            }
        };
 
        from_json::<Config>(&wifi_json)
            .map_err(|e| Error::UnhandledOwned(format!("Failed to deserialize config JSON: {e}")))
            .and_then(|config| {
                unsafe {
                    CONFIG = config;
                }
                log_info!(APP_TAG, "Config loaded successfully");
                Ok(unsafe { &mut *&raw mut CONFIG })
            })
    }

    pub fn save()  -> Result<&'static mut Self> {
        let mut file_name = FileBytes::new_by_str(FS_CONFIG_DIR);
        file_name.append_str(FS_SEPARATOR_DIR);
        file_name.append_str(Config::FILE_NAME);

        unsafe {
            to_json(&*&raw const CONFIG)
                .map_err(|e| Error::UnhandledOwned(format!("Failed to serialize config to JSON: {e}")))
                .and_then(|json| {
                    let json_bytes = json.into_bytes();

                    let mut file = match Filesystem::open_with_as_sync_str(&file_name, open_flags::WRONLY | open_flags::CREAT) {
                        Ok(file) => file,
                        Err(e @ Error::ReturnWithCode(-2) )  => {
                            log_info!(APP_TAG, "Failed to open config file: {e}, try to create it");
                            Filesystem::open_with_as_sync_str(&file_name, open_flags::WRONLY | open_flags::CREAT)?
                        }
                        Err(e) => return Err(e),
                    };

                    file.write(&json_bytes, true)?;

                    log_info!(APP_TAG, "Config saved successfully");
                    Ok(&mut *&raw mut CONFIG)
                })
        }
    }

    pub fn get_version(&self) -> u8 {
        mutex().lock();
        let version = self.version;
        mutex().unlock();
        version
    }

    pub fn get_serial(&self) -> &Bytes<16> {
        mutex().lock();
        let serial = &self.serial;
        mutex().unlock();
        serial
    }

    pub fn get_timezone(&self) -> u16 {
        mutex().lock();
        let timezone = self.timezone;
        mutex().unlock();
        timezone
    }

    pub fn is_daylight_saving_time(&self) -> bool {
        mutex().lock();
        let dst = self.daylight_saving_time;
        mutex().unlock();
        dst
    }

    pub fn set_serial(&mut self, serial: Bytes<16>) {
        mutex().lock();
        self.serial = serial;
        mutex().unlock();
    }

    pub fn set_timezone(&mut self, timezone: u16) {
        mutex().lock();
        self.timezone = timezone;
        mutex().unlock();
    }

    pub fn set_daylight_saving_time(&mut self, dst: bool) {
        mutex().lock();
        self.daylight_saving_time = dst;
        mutex().unlock();
    }

    pub fn set_user(&mut self, index: usize, user: UserConfig) {
        mutex().lock();
        if index < self.users.len() {
            self.users[index] = user;
        }
        mutex().unlock();
    }

    pub fn get_user(&self, index: usize) -> Result<&UserConfig> {
        mutex().lock();
        if index < self.users.len() {
            let user = &self.users[index];
            mutex().unlock();
            Ok(user)
        } else {
            mutex().unlock();
            Err(Error::OutOfIndex)
        }
    }

    pub fn get_wifi_config(&mut self) -> &mut WifiConfig {
        &mut self.wifi
    }
}